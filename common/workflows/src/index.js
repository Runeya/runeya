const fs = require('fs');
const pathfs = require('path');
const walker = require('./walker');

const root = pathfs.resolve(__dirname, '..', '..', '..');
const githubRoot = pathfs.resolve(root, '.github');
const workflowsRoot = pathfs.resolve(githubRoot, 'workflows');

const workflowTemplateDockerPath = pathfs.resolve(githubRoot, 'workflow-template-docker.yml');
const workflowTemplateDocker = fs.readFileSync(workflowTemplateDockerPath, 'utf-8');

const workflowTemplateTestPath = pathfs.resolve(githubRoot, 'workflow-template-test.yml');
const workflowTemplateTest = fs.readFileSync(workflowTemplateTestPath, 'utf-8');

const workflowTemplateDeployPath = pathfs.resolve(githubRoot, 'workflow-template-deploy.yml');
const workflowTemplateDeploy = fs.readFileSync(workflowTemplateDeployPath, 'utf-8');

const workflowTemplatePluginPath = pathfs.resolve(githubRoot, 'workflow-template-plugin.yml');
const workflowTemplatePlugin = fs.readFileSync(workflowTemplatePluginPath, 'utf-8');

const prependText = `
# Autogenerated by @runeya/common-workflows package
# If you must edit this file, edit files in .github/workflow-*.yml
# Then launch "yarn ci:generate"

`;
(async () => {
  let files = await walker.import({ paths: ['.'] });
  files = files.sort((a, b) => a.localeCompare(b));
  await generateDeployWorkflows(files);
  await generateTestWorkflows();
})();
async function generateDeployWorkflows(files) {
  let workflow = workflowTemplateDeploy;
  workflow = prependText + workflow;

  // Generate docker steps
  const dockerfiles = files.filter((file) => file.endsWith('Dockerfile'));
  dockerfiles.forEach((dockerfilePath) => {
    const LOCATION = pathfs.dirname(dockerfilePath).split(root).join('').split(pathfs.sep)
      .filter((a) => a)
      .join('/');
    const NAME_ROUTE = pathfs.dirname(dockerfilePath).split(root).join('').split(pathfs.sep)
      .filter((a) => a)
      .join('-');
    workflow += `${workflowTemplateDocker
      .replaceAll(/{{LOCATION}}/gi, LOCATION)
      .replaceAll(/{{NAME_ROUTE_SANITIZED}}/gi, NAME_ROUTE.replaceAll('.', '_'))
      .replaceAll(/{{NAME_ROUTE}}/gi, NAME_ROUTE)}\n`;
  });

  // Generate plugin steps - find all package.json files in modules directory that might contain plugin:publish script
  const pluginPackageJsons = files.filter((file) => 
    file.includes('/modules/') && 
    file.endsWith('package.json') && 
    !file.includes('node_modules')
  );
  
  pluginPackageJsons.forEach((packageJsonPath) => {
    try {
      const packageJson = JSON.parse(fs.readFileSync(pathfs.resolve(root, packageJsonPath), 'utf-8'));
      
      // Check if the package has a plugin:publish script
      if (packageJson.scripts && packageJson.scripts['plugin:publish']) {
        const LOCATION = pathfs.dirname(packageJsonPath);
        const NAME_ROUTE = pathfs.dirname(packageJsonPath).split(pathfs.sep)
          .filter((a) => a)
          .join('-');
        workflow += `${workflowTemplatePlugin
          .replaceAll(/{{LOCATION}}/gi, LOCATION)
          .replaceAll(/{{NAME_ROUTE_SANITIZED}}/gi, NAME_ROUTE.replaceAll('.', '_'))
          .replaceAll(/{{NAME_ROUTE}}/gi, NAME_ROUTE)}\n`;
      }
    } catch (error) {
      // Skip invalid package.json files
      console.warn(`Warning: Could not parse ${packageJsonPath}`);
    }
  });

  fs.writeFileSync(pathfs.join(workflowsRoot, 'all-deploy.yml'), workflow);
}

async function generateTestWorkflows() {
  let workflow = workflowTemplateTest;
  workflow = prependText + workflow;
  fs.writeFileSync(pathfs.join(workflowsRoot, 'all-test.yml'), workflow);
}
